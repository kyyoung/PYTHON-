# -*- coding: utf-8 -*-
"""
Created on Tue Apr 14 10:10:25 2020

@author: KITCOOP
"""

#객체를 외부 파일로 내보내기 
L1=[[1,2,3,4], [5,6,7,8]]

for i in L1:
    for j in i:
        print(j)
    
#--
c1 = open('write_test1.txt', 'w') #쓰기모드 커서 선언 
c1.writelines(L1) #에러 발생, 리스트 쓰기 불가 
c1.close ()

#--
c1 = open('write_test.txt', 'w') #쓰기모드 커서 선언 
c1.writelines(str(L1))  #문자열로 저장 가능  
c1.close ()

#--
c1 = open('write_test2.txt', 'w') #쓰기모드 커서 선언 
for i in L1:
    c1.writelines(str(i))          #엔터 없이 
c1.close ()

#--
c1 = open('write_test2.txt', 'w') #쓰기모드 커서 선언 
for i in L1:
    c1.writelines(str(i) + '\n')          #엔터 있음  
c1.close ()

#형변환 
int/ float/ str
'%.2f' % x 


#데이터 분석 in Python, 벡터 연산 됨 
#numpy : 다차원 배열 생성 및 연산을 위한 패키지(모듈)
import numpy as np 

#array : 매트릭스  
-다차원 
-동일한 데이터 타입만 허용함  ---> 뉴럴네트워크의 속도 향상을 위해 동일한 데이터 타입만 허용함  
-뉴럴네트워크의 기본 데이터 구조
(뉴럴네트워크중에서 히든레이어가 많은 모델이 딥러닝모델) 
-비정형데이터를 처리하기 위해 정렬이 중요함 

#1. 생성 
a1=np.arange(1,10)  #1:10 = > 1~9 
a2=np.arange(1,19, dtype='float')
type(a1) #numpy.ndarray 

a3 = np.array([1,2,3,4])
a4 = np.array([[1,2], [3,4]])  ;a4

#2.배열과 관련된 주요 메서드 
a1.dtype  #배열을 구성하는 데이터 타입: 어레이 안에 있는 데이터타입이 무엇인지 확인시켜줌 
a1.shape  #배열의 사이즈 : 다차원 배열의 사이즈를 알려줌 
a1.reshape(3,3) #배열의 사이즈 변경 

a2.dtype 
a2.reshape(3,3,2) #3층,3행,2열
a2 = a2.reshape(2,3,3) #2층 3행 3열  

#[참고: 다차원을 나타내는 순서]
in R : 행 열 층 ... 
in Python: ... 층 행 열


a4.ndim #차원을 알려주는 명령어 
a2.ndim 

#3.연산 
a5=np.array([10,20,30,40]).reshape(2,2)
a6=np.array([10,20])
a7=np.array([10,20,30])

a4+1  #스칼라 연산 가능 
a4 + a5 #서로 같은 크기를 갖는 배열끼리 연산 가능 
a4 + a6 # 서로 다른 크기를 갖는 배열 연산 가능  
a4 + a7 # (2,2) + (3, )-->(2,2) + (1,3)형태 : 서로 다른 크기를 갖는 배열 연산 불가능 

#broadcast : 배열의 반복연산 -- 반복을 이끌어 내기 위한 일치하는 숫자가 필요 
1. 양쪽배열에 크기를 나타내는 숫자가 동일한 것이 존재해야함(행이나 열 둘 중 하나는 배열의 수가 같아야함)
2. 작은쪽 배열의 크기를 나타내는 나머지 숫자는 반드시 1이어야 함 (작은쪽의 배열의 행렬 형태는 n*1 이나 1*n 이어야함)
3. 같은 크기를 나타내는 숫자는 동일한 방향이어야함 (행의 숫자가 같던가 열의 숫자가 동일해야함)
arr1=np.arange(1,9).reshape(2,4) #2*4
arr2=np.array([10,20]) #1*2
arr3=np.array([10,20,30,40])  #1*4

arr1+arr2 #연산불가, 2*4 + 1*2 
arr1+ arr2.reshape(2,1)  #연산가능, 2*4 + 2*1 
arr1+arr3 #연산가능 2*4 +1*4

#연습문제- 아래 배열이 연산 가능하도록 만들어라 
a10 = np.arange(1,25).reshape(2,3,4) #2층 3행 4열
a20 = np.arange(1,13) #1행 12열 
a30 = np.array([10,20,30]) #1행 3열 

1) a10 + a20 
a10 + a20.reshape(1,3,4)
    
2) a10 + a30 
a10 + a30.reshape(1,3,1)

#4.색인 
L1 = [[1,2,3],[4,5,6],[7,8,9]]
arr1 = np.array(L1)
arr2 = np.arange(1,25).reshape(2,3,4)

L1[1,1] #불가
L1[1][1] #가능

#행추출
arr1[1,1] #가능
arr1[0,] #가능- 첫번째 행 추출, 컬럼범위 생략 

#컬럼추출
arr1[,0] #불가능 - 전범위에 대한 생략 불가 R에서는 가능 
arr1[:,0] #가능 - 첫번째 컬럼 추출, 행범위 생략 불가- 전범위 표시 : 꼭 해줘야함 
arr1[:, 0:1] # 첫번째 컬럼 추출, 행범위 생략 불가(차원 축소 방지, drop = F in R )

#행과 컬럼 추출 
arr1[[0,2], :] #가능 - 여러개 범위선택 가능 
arr1[1:3, :] #슬라이스 객체를 색인값으로 전달 가능 

#5,6,8,9 뽑아보기 
arr1[1:3, [1,2]] #슬라이스 색인, 리스트 색인으로 가능 
arr1[1:3, 1:3] #슬라이스 색인 가능
arr1[[1,2],[1,2]] #5,9 출력 리스트색인을 각각 쓰면 p(1,1), p(2,2)로 해석됨 
arr1[np.ix_([1,2],[1,2])] #np.ix()사용하면 포인트 색인이 아닌 원래 알고 있던 리스트 색인 
arr1[[1,2],:][:,[1,2]] #리스트 색인 각각 사용, 앞의 색인과 뒤의 색인의 차원은 맞춰야함 

#4, 7출력 
arr1[[1,2],0]
arr1[[1,2], :][:,0]  #앞에 2차원 뒤에 1차원 가능 
arr1[:,0][[1,2], :] #too many indices for array 앞에 1차원 뒤에 2차원은 불가   
arr1[: ,0][[1,2]] #앞에 1차원이기 때문에 뒤에도 1차원으로  

#예제) 다음의 arr2에서 
arr2=np.arange(1,21).reshape(5,4)
1) 10,11,14,15,18,19 출력 
arr2[2:5, 1:3]    

arr2[np.ix_([2,3,4],[1,2])]
arr2[[2,3,4], :][:,[1,2]]

2) 6,7,8 출력 
arr2[1, 1:4]

arr2[1,[1,2,3]]

#예제) 다음의 arr3에서 첫번째 컬럼값 추출, 각 컬럼마다 값을 더해 출력 
arr3= np.arange(1,10).reshape(3,3)
arr3 + arr3[:,0:1]


